# Factory method for MarkerList objects
# 
# Author: Renaud Gaujoux
# Created: 30 Nov 2012
###############################################################################

#' @include MarkerList-class.R
NULL

############
# FACTORY
############
#' This method acts as a Constructor-Copy that returns the input MarkerList 
#' object unchanged if no other argument are passed, or creates a new 
#' MarkerList object based on \code{object}, using the arguments in \code{...} 
#' to initialise the slots.
#' 
#' @examples
#' ## create a MarkerList from another MarkerList
#' m <- rMarkerList(3, 4, names=TRUE)
#' m
#' MarkerList(m, setName=mkScalar("Another list of markers"))
#' 
setMethod('MarkerList', 'MarkerList', 
		function(object, ...){
			if( nargs() == 1L ) object 
			else new('MarkerList', object, ...)
		}
)
#' Creates a \code{MarkerList} object as per \code{new('MarkerList', ...)} or
#' from a file (see section \emph{Loading from files}).
#' 
#' @section Loading from files:
#' 
#' Loading marker lists directly from files can be performed by providing filename to argument \code{file}.
#' Currently this functionality is only implemented for plain text files that contain one marker 
#' feature description per line: marker names (e.g., ENTREZID), marker set (e.g., cell type name) and optionally 
#' some numeric value (e.g. specificity score).
#' 
#' In this case all arguments in \code{...} are passed to \code{\link{read.table}}, 
#' and should be set so that the loaded data.frame conforms with one of the following formats:
#' \describe{
#' \item{at least one column and row names:}{ the row names are used as marker names,
#' column 1 as marker set.
#' Note that tables with automatic rownames generated by \code{read.table} (i.e. 1,2,3, etc..) 
#' are not considered as proper rownames.}
#' \item{two columns and no row names:}{column 1 is used for marker names, 
#' column 2 for the marker set names.}
#' \item{single column and no (or automatic) rownames:}{column is used for marker set names, 
#' the markers are taken to be integers.}
#' }
#' Optionally, in all cases, the next numeric column after the one used for marker set names 
#' is used for associated numeric values.
#' 
#' @param file filename of a file that contains marker data.
#' Conneciton objects are also supported.
#' 
#' @examples
#' 
#' txtdesc <- function(x) textConnection(paste(x, collapse="\n"))
#' 
#' # two columns
#' ml <- MarkerList(file=txtdesc(c("m1 a", "m2 b", "m3 a")))
#' summary(ml)
#' 
#' # single column with row.names
#' ml2 <- MarkerList(file=txtdesc(c("m1 a", "m2 b", "m3 a")), row.names=1L)
#' identical(ml, ml2)
#' 
#' # three columns with values
#' mlv <- MarkerList(file=txtdesc(c("m1 a 1.4", "m2 b 1.5", "m3 a 2.6")))
#' summary(mlv)
#' print(mlv)
#' 
#' # skip an extra column
#' mlv <- MarkerList(file=txtdesc(c("m1 a 1.4", "m2 b 1.5", "m3 a 2.6")))
#' summary(mlv)
#' print(mlv)
#' 
#' # single column: index MarkerList
#' ml <- MarkerList(file=txtdesc(c("a", "b", "a")))
#' summary(ml)
#' 
#' 
setMethod('MarkerList', 'missing', 
	function(object, ..., file=NULL) {
		if( is.null(file) ) new('MarkerList', ...)
		else{
			tab <- read.table(file=file, ...)
			ival <- 0L
			m <- NULL
			if( !nrow(tab) ){
				# do nothing: empty MarkerList
				m <- MarkerList()
			}else if( !is.null(rownames(tab)) && !identical(rownames(tab), as.character(1:nrow(tab))) ){
				ival <- 2L
				m <- setNames(tab[, 1L], rownames(tab))
			}else if( ncol(tab) >= 2L ){
				ival <- 3L
				m <- setNames(tab[, 2L], tab[, 1L])
			} else if( ncol(tab) == 1L ){
				m <- MarkerList(tab[, 1L])
			}else{
				stop("Could not load marker list from file '", file, "': table format not supported")
			}
			
			# build MarkerList object, adding values if possible
			if( !isMarkerList(m) && length(m) ){
				m <- factor(m)
				if( ival && ncol(tab) >= ival ){
					wnum <- which(sapply(tab, is, 'numeric'))
					if( length(wnum) ){ # use values
						val <- tab[, wnum[1L]] # values
						# build marker list
						m <- MarkerList(setNames(val, names(m)), names=m)
					}else{ # no values
						m <- MarkerList(m)
					}
				}else{
					m <- MarkerList(m)
				}
			}
			m
		}
	}
)
#' Default method that tries to retrieve marker data from the input object
#' using the function \code{\link{getMarkers}}.
#'    
setMethod('MarkerList', 'ANY', 
		function(object, ...){
			MarkerList(getMarkers(object), ...)
		}
)
#' Creates a \code{MarkerList} object treating the input vector as a factor, 
#' except if the input is a numeric vector of scores.
#' See \code{\link{MarkerList,factor-method}}.
#' 
#' If \code{object} is numeric, one also needs to supply a factor that defines
#' the cell types.
#' Markers ids are taken from the names \code{object}, or, if missing, from 
#' the names of \code{types}. 
#'   
setMethod('MarkerList', 'vector', 
	function(object, ..., names=NULL){
		
		types <- names
		names <- match.fun('names')
		if( hasValues(object) ){
			if( is.null(nm <- names(object)) ){
				if( is.null(nm <- names(types)) )
					stop("Could not infer marker type names: arguments `object` or `types` have no names.")
			}
			if( !is.factor(types) )	types <- factor(types, levels=unique(types))
			# split values by type
			l <- split(object, types)
			# create object
			MarkerList(l, ...)
		}else{
			# use provided types if possible
#			if( !is.null(types) ) object <- setNames(object, types)
			MarkerList(as.factor(object), ...)
		}
	}
)

#' Creates a MarkerList object using the -- normally -- duplicated names of 
#' the input vector as types, and the values as marker indexes.
#' See \code{\link{MarkerList,factor-method}}.
#' 
#' @examples
#' 
#' ## create a MarkerList from an integer vector
#' # names are required
#' try( MarkerList( 1:15 ) )
#' # repeated names define marker sets
#' MarkerList( setNames(1:12, rep(letters[1:3], 4)) ) 
#' 
setMethod('MarkerList', 'integer', 
		function(object, ...){
			if( is.null(names(object)) )
				stop("MarkerList - Invalid integer vector: must have -- duplicated -- names.")		
			l <- split(setNames(object, NULL), factor(names(object)))
			MarkerList(l, ...)
		}
)
#' Either loads a marker list from the internal registry (see \code{\link{cellMarkers}}), 
#' or use the names of \code{object} for defining the sets and the values (strings) 
#' as marker identifiers.
#' 
#' If no names are present, then it uses the character vector as a factor, whose levels 
#' are the sets, and creates an index marker list with 
#' \code{MarkerList,factor-method}.
#' 
#' @param names factor or character vector that defines the types associated to each marker 
#' in \code{object}. 
#' 
#' @examples 
#'
#' ## create a MarkerList from a character vector
#' # no names: repeated values define the sets
#' v <- sample(letters[1:3], 15, replace=TRUE)
#' MarkerList(v)
#' # with names: repeated names define the sets
#' m <- str_c('M', 1:15)
#' MarkerList( setNames(m, v) )
#' 
setMethod('MarkerList', 'character', 
		function(object, ..., names=NULL){
			types <- names
			names <- match.fun('names')
			if( length(object) == 1L && is.null(names(object)) ) cellMarkers(object, ...)
			else{
				if( !is.null(types) ) object <- setNames(object, types)
				if( !is.null(names(object)) )
					MarkerList(factor(setNames(names(object), object)), ...)
				else callNextMethod()
			}
		}
)
#' Create a MarkerList object by splitting the input factor into a list of its
#' different levels.
#' 
#' If \code{object} has names they are used as marker identifiers, otherwise an
#' index marker list is created.
#' 
#' @examples 
#' 
#' ## create a MarkerList from a factor
#' f <- factor(sample(letters[1:3], 15, replace=TRUE))
#' MarkerList(f)
#' MarkerList( addNames(f, 'M') )
#' 
setMethod('MarkerList', 'factor', 
		function(object, ...){
			
			# split the names according to the factor's levels
			mnames <- if( !is.null(names(object)) ) names(object) else seq_along(object)
			l <- split(mnames, object)			
			# create object from list
			MarkerList(l, ...)
			
		}
)
#' Convert a standard list into a MarkerList object.
#' 
#' The list should contain no duplicated marker identifiers (either as strings or 
#' integer indexes).
#' 
#' @param unlist logical that indicates if the result should be a vector representation
#' of the marker list. In this case auxiliary numeric values are dropped from the list.
#' @param quiet logical that indicates if warnings should be silenced if any.
#' 
#' @examples
#' 
#' ## create an index MarkerList from a standard list
#' m <- list(1:3, 5:10, c(4L,12L)) 
#' MarkerList(m) 
#' 
#' # with mixed integer/numeric, a warning is thrown 
#' m <- list(1:3, 5:10, c(4,12)) 
#' MarkerList(m)
#' 
setMethod('MarkerList', 'list', 
		function(object, ..., unlist=FALSE, quiet = FALSE){
			
			# ensure there are names
			object <- addNames(object, 'Type_')
			
			# return the marker list
			if( unlist ){
				unlist2( dropvalues(object) )
			}else{
				
#			# convert elements to GeneSet or GeneValueSet objects if necessary
#			n <- 0L
#			l <- lapply(seq_along(object), function(i, ...){
#				m <- object[[i]]
#				if( !is.numeric(m) ) res <- GeneValueSet(m, ..., setName=names(object)[i]) 
#				else{
#					res <- GeneValueSet(m, ..., setName=names(object)[i], shift=n)
#					n <<- n + length(geneIds(res))
#				}
#				res
#			}, ...)
				# fix mix of integer and numeric
				cl <- sapply(object, class)
				if( all(c('integer', 'numeric') %in% cl) ){
					if( !quiet ){
						warning("MarkerList - Converting mixed integer/numeric elements into integers.")
					}
					object <- sapply(object, function(x){
						as.integer(x)		
					}, simplify=FALSE)
				}
				as.MarkerList(object, ...)
			}
		}
)


.extractMarkers_signatures <- function(object, values=TRUE, add.names=TRUE){
	
	object <- exprs(object)
	jmax <- max.col(object)
	# get set names
	types <- if( !is.null(colnames(object)) ){
				types <- colnames(object)[jmax]
				factor(types, levels=colnames(object))
			} else {
				types <- (1:ncol(object))[jmax]
				factor(types, levels=1:ncol(object))
			}
	# extract values
	if( values ){
		# add rownames if necessary
		if( is.null(rownames(object)) ){
			if( add.names )
				warning("MarkerList - Rownames were generated (as integers) to be able to attach row maximum values.")
			else
				stop("MarkerList - Cannot attach row maximum values: the input matrix has no rownames.")
			rownames(object) <- 1:nrow(object)
		}
		
		val <- setNames(mapply(function(i, j) object[i,j], 1:nrow(object), jmax), rownames(object))
		split(val, types)
	}else{
		# use rownames or indexes
		m <- if( !is.null(rownames(object)) ) rownames(object) else 1:nrow(object)
		split(m, types)
	}
} 

#' Creates a MarkerList object from a numeric matrix, that is assumed to 
#' have one column per marker set, e.g., a matrix cell type-specific signature.
#' 
#' This method uses a very simple heuristic, which associate each row in a 
#' matrix to the column with the maximum entry (see \code{\link{max.col}}).
#' 
#' For more complex and finer ways of extracting markers from expression 
#' data see \code{\link{extractMarkers}}.
#'
#' The rownames are used as marker identifiers if present. 
#' If not otherwise specified, each marker is associated with its 
#' correspondong row maximum, which is also stored in the 
#' result object.
#' 
#' @param values a logical that indicates if the row maximums should be 
#' embedded into the marker list.
#' @param add.names logical that indicates if names should be added if 
#' necessary (\code{TRUE}).
#' This is used in the case the input matrix has no rownames and the 
#' row maximum values are requested to be attached to the marker list 
#' (\code{values=TRUE}), which throws an error if \code{add.names=FALSE}. 
#'
#' @examples
#' 
#' ## create a MarkerList from a matrix of signatures
#' s <- rmatrix(10,4)
#' m <- MarkerList( s )
#' # the object has values, that can be dropped is necessary
#' m
#' dropvalues(m)
#' # or directly
#' identical(dropvalues(m), MarkerList(s, values=FALSE))
#' 
setMethod('MarkerList', 'matrix', 
		function(object, ..., values=TRUE, add.names=TRUE){
			
			m <- .extractMarkers_signatures(object, values=values, add.names=add.names)
			MarkerList(m, ...)
			
		}
)
#' Create a MarkerList from the expression matrix of an \code{\linkS4class{ExpressionSet}}
#' object.
#' 
#' This is a shortcut for \code{MarkerList(exprs(object), ...)}.
setMethod('MarkerList', 'ExpressionSet', 
		function(object, ...){
			m <- MarkerList(exprs(object), ...)
			# pass on annotations
			annotation(m) <- annotation(object)
			m
		}
)

